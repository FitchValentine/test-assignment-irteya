# TA Service

REST API сервис для управления пользователями, продуктами и заказами на Go с использованием PostgreSQL.

## Содержание

- [Архитектура](#архитектура)
- [Технологический стек](#технологический-стек)
- [Структура проекта](#структура-проекта)
- [Установка и запуск](#установка-и-запуск)
- [API Документация](#api-документация)
- [Тестирование](#тестирование)
- [Docker](#docker)

## Архитектура

Проект реализован на основе **Hexagonal Architecture** (также известной как Ports & Adapters) с элементами **Clean Architecture**. Выбор этой архитектуры обусловлен требованиями к гибкости, тестируемости и независимости бизнес-логики от инфраструктуры.

### Почему Hexagonal Architecture?

#### Сравнение с альтернативами

**1. Hexagonal Architecture vs MVC (Model-View-Controller)**
- **MVC**: Тесно связывает представление с бизнес-логикой, сложно тестировать без UI
- **Hexagonal**: Бизнес-логика изолирована, можно тестировать без HTTP/БД
- **Вывод**: Для REST API без UI MVC избыточен, Hexagonal дает лучшую изоляцию

**2. Hexagonal Architecture vs Layered Architecture (3-tier)**
- **Layered**: Зависимости идут сверху вниз, нижние слои зависят от верхних (антипаттерн)
- **Hexagonal**: Зависимости направлены внутрь (Dependency Inversion), Domain не зависит от инфраструктуры
- **Вывод**: Hexagonal обеспечивает правильное направление зависимостей

**3. Hexagonal Architecture vs Onion Architecture**
- **Onion**: Более строгие правила зависимостей, сложнее для небольших проектов
- **Hexagonal**: Проще в реализации, достаточно гибкая для большинства случаев
- **Вывод**: Hexagonal - оптимальный баланс между строгостью и простотой

#### Преимущества выбранной архитектуры

1. **Независимость от инфраструктуры**
   - Domain модели не знают о PostgreSQL, HTTP, JSON
   - Можно заменить БД (PostgreSQL → MongoDB) без изменения бизнес-логики
   - Можно добавить gRPC адаптер параллельно с REST

2. **Тестируемость**
   - Бизнес-логика тестируется без БД через моки репозиториев
   - Каждый слой тестируется изолированно
   - Интерфейсы репозиториев позволяют легко создавать in-memory реализации

3. **Гибкость расширения**
   - Добавление нового адаптера (например, GraphQL) не требует изменения Domain
   - Можно добавить кэширование, очереди без изменения Service слоя
   - Легко добавить новые источники данных (API, файлы)

4. **Явные границы**
   - Четкое разделение: что является бизнес-правилом, а что - технической деталью
   - Маппинг между слоями делает преобразования данных явными
   - Легче понять поток данных и найти место для изменений

5. **Соответствие принципам SOLID**
   - **S**ingle Responsibility: каждый слой решает свою задачу
   - **O**pen/Closed: можно расширять через новые адаптеры без изменения ядра
   - **L**iskov Substitution: интерфейсы репозиториев позволяют подменять реализации
   - **I**nterface Segregation: интерфейсы разделены по доменам (User, Product, Order)
   - **D**ependency Inversion: Domain не зависит от деталей, детали зависят от абстракций

#### Структура Hexagonal Architecture в проекте

**Порты (Ports)** - интерфейсы, определяющие контракты:
- `UserRepositoryInterface`, `ProductRepositoryInterface`, `OrderRepositoryInterface`

**Адаптеры (Adapters)** - реализации портов:
- **Входящие**: HTTP Handler (REST API)
- **Исходящие**: PostgreSQL Repository

**Ядро (Core)** - бизнес-логика без зависимостей:
- Domain модели (`internal/domain/`)
- Service слой (`internal/service/`)

### Слои приложения

```
┌─────────────────────────────────────┐
│   HTTP Handler Layer (REST API)     │  ← Внешний слой
├─────────────────────────────────────┤
│   Service Layer (Business Logic)    │  ← Бизнес-логика
├─────────────────────────────────────┤
│   Repository Layer (Data Access)    │  ← Доступ к данным
├─────────────────────────────────────┤
│   Database (PostgreSQL)             │  ← Хранилище
└─────────────────────────────────────┘
```

#### 1. **Handler Layer** (`internal/handler/`)
- **Назначение**: Обработка HTTP запросов, валидация входных данных, преобразование DTO
- **Ответственность**: 
  - Прием HTTP запросов
  - Валидация через Gin binding
  - Маппинг DTO → Domain
  - Формирование HTTP ответов

#### 2. **Service Layer** (`internal/service/`)
- **Назначение**: Бизнес-логика приложения
- **Ответственность**:
  - Валидация бизнес-правил (возраст ≥18, пароль ≥8 символов)
  - Проверка наличия товара на складе
  - Координация между репозиториями
  - Хеширование паролей

#### 3. **Repository Layer** (`internal/repository/`)
- **Назначение**: Абстракция доступа к данным
- **Ответственность**:
  - SQL запросы к PostgreSQL
  - Маппинг DB модели → Domain модели
  - Транзакции для атомарности операций

#### 4. **Domain Layer** (`internal/domain/`)
- **Назначение**: Доменные модели без зависимостей от инфраструктуры
- **Сущности**: User, Product, Order, OrderItem

### Поток данных

```
HTTP Request
    ↓
Handler (DTO) → маппинг → Service (Domain)
    ↓
Service (Business Logic) → маппинг → Repository (DB Model)
    ↓
Repository → PostgreSQL
    ↓
Response (обратный путь через маппинги)
```

**Почему такой подход?**
- **Разделение ответственности**: каждый слой решает свою задачу
- **Независимость от БД**: можно заменить PostgreSQL на другую БД, изменив только Repository
- **Тестируемость**: легко мокировать репозитории для unit-тестов
- **Масштабируемость**: легко добавлять новые функции без изменения существующего кода

## Технологический стек

### Выбор технологий и обоснование

#### **REST API вместо gRPC**

**Почему REST:**
- **Простота интеграции**: стандартный HTTP/JSON, не требует специальных клиентов
- **Универсальность**: работает из браузера, мобильных приложений, любых HTTP-клиентов
- **Отладка**: легко тестировать через curl, Postman, браузер
- **Меньше зависимостей**: не нужны protobuf компиляторы, генерация кода
- **Стандартизация**: REST - де-факто стандарт для публичных API

**Когда бы выбрали gRPC:**
- Высоконагруженные микросервисы с внутренней коммуникацией
- Строгая типизация и контракты через protobuf
- Необходимость streaming (gRPC streams)
- Микросервисная архитектура с множеством сервисов

**Вывод для проекта**: REST оптимален для монолитного сервиса с простым CRUD функционалом.

#### **Gin Framework** (`github.com/gin-gonic/gin`)

**Альтернативы:**
- **net/http** (стандартная библиотека): слишком низкоуровневый, много boilerplate
- **Echo**: похож на Gin, но менее популярен
- **Fiber**: быстрый, но менее зрелый, несовместим с net/http
- **Chi**: минималистичный роутер, но без встроенной валидации

**Почему Gin:**
- **Производительность**: один из самых быстрых HTTP фреймворков (benchmarks показывают ~100k req/s)
- **Простота**: минималистичный API, легко читаемый код, быстрое стартование
- **Middleware**: встроенная поддержка цепочки middleware (logger, recovery, tracer)
- **Валидация**: интеграция с `go-playground/validator` из коробки
- **Популярность**: широко используется, много примеров и документации
- **Совместимость**: работает поверх стандартного `net/http`, можно использовать стандартные пакеты


#### **PostgreSQL**

**Альтернативы:**
- **MySQL/MariaDB**: менее гибкая работа с JSON, слабее поддержка массивов
- **MongoDB**: NoSQL, но теряем ACID транзакции, критичные для заказов
- **SQLite**: встроенная БД, но нет конкурентного доступа, не для production

**Почему PostgreSQL:**
- **ACID транзакции**: критично для атомарности операций заказа (проверка наличия + резервирование товара)
- **JSONB**: эффективное хранение и индексация JSON для исторических снимков заказов
- **Массивы**: нативная поддержка `TEXT[]` для тегов продуктов без дополнительных таблиц
- **Ограничения**: CHECK constraints для валидации на уровне БД (age ≥ 18, quantity ≥ 0)
- **Расширяемость**: поддержка пользовательских типов, полнотекстовый поиск, индексы GIN/GiST
- **Надежность**: проверенная временем реляционная БД с сильной типизацией
- **Производительность**: оптимизатор запросов, индексы, партиционирование

**Использование в проекте:**
- Транзакции для атомарности создания заказа
- JSONB для `order_history.snapshot_data`
- Массивы для `products.tags`
- CHECK constraints для бизнес-правил на уровне БД

#### **Zap Logger** (`go.uber.org/zap`)

**Альтернативы:**
- **logrus**: популярный, но медленнее из-за reflection
- **zerolog**: быстрый, но менее гибкий API
- **стандартный log**: слишком простой, нет структурированного логирования

**Почему Zap:**
- **Производительность**: структурированное логирование с минимальными аллокациями памяти
- **Типобезопасность**: compile-time проверка полей через `zap.String()`, `zap.Int()`
- **Контекст**: возможность добавлять поля в контексте запроса (trace_id, user_id)
- **Уровни**: DEBUG, INFO, WARN, ERROR с возможностью фильтрации
- **Форматирование**: поддержка JSON и консольного вывода
- **Производство**: используется в production в Uber, проверен на нагрузке

**Использование в проекте:**
- Логирование HTTP запросов с контекстом (method, path, status, latency, trace_id)
- Логирование паник с полным контекстом для отладки
- Структурированные логи для парсинга в ELK, Loki, CloudWatch

#### **Stretchr Testify** (`github.com/stretchr/testify`)

**Альтернативы:**
- **стандартный testing**: слишком много boilerplate, нет assert
- **gomock**: генерация моков, но сложнее в использовании
- **testify/mock**: ручное создание моков, но более гибко

**Почему Testify:**
- **Удобство**: `assert.Equal()`, `assert.Error()` вместо `if got != want { t.Fatal() }`
- **Читаемость**: тесты читаются как документация
- **Mock**: встроенная поддержка моков через `mock.Mock`
- **Стандарт**: широко используется в Go сообществе, много примеров
- **Интеграция**: работает со стандартным `testing` пакетом

**Использование в проекте:**
- Unit-тесты для Service слоя с моками репозиториев
- Проверка бизнес-логики без реальной БД
- Изоляция тестов через интерфейсы репозиториев

#### **bcrypt** (`golang.org/x/crypto`)

**Альтернативы:**
- **MD5/SHA**: устаревшие, небезопасные для паролей (быстрое хеширование)
- **scrypt/argon2**: более современные, но bcrypt достаточно для большинства случаев
- **plain text**: категорически недопустимо

**Почему bcrypt:**
- **Безопасность**: специально разработан для хеширования паролей, устойчив к rainbow tables
- **Адаптивность**: автоматическая настройка сложности (cost factor), можно увеличивать со временем
- **Стандарт**: де-факто стандарт для хеширования паролей, используется везде
- **Встроенность**: часть стандартной библиотеки Go (`golang.org/x/crypto`)
- **Простота**: один вызов `bcrypt.GenerateFromPassword()`

**Использование в проекте:**
- Хеширование паролей при регистрации пользователя
- Сравнение паролей при аутентификации (если добавим в будущем)

## Структура проекта

```
ta/
├── cmd/
│   └── server/
│       └── main.go              # Точка входа приложения
├── internal/
│   ├── domain/                  # Доменные модели (чистые структуры)
│   │   ├── user.go
│   │   ├── product.go
│   │   └── order.go
│   ├── handler/                 # HTTP обработчики
│   │   ├── user_handler.go
│   │   ├── product_handler.go
│   │   └── order_handler.go
│   ├── service/                 # Бизнес-логика
│   │   ├── user_service.go
│   │   ├── product_service.go
│   │   ├── order_service.go
│   │   └── *_test.go           # Unit тесты
│   ├── repository/              # Доступ к данным
│   │   ├── interfaces.go        # Интерфейсы для тестирования
│   │   ├── user_repo.go
│   │   ├── product_repo.go
│   │   └── order_repo.go
│   ├── dto/                     # Data Transfer Objects
│   │   ├── request.go
│   │   └── response.go
│   ├── mapper/                  # Маппинг между слоями
│   │   └── mapper.go
│   ├── middleware/              # HTTP middleware
│   │   ├── logger.go
│   │   ├── recovery.go
│   │   └── tracer.go
│   └── config/                  # Конфигурация
│       └── config.go
├── migrations/                  # SQL миграции
│   ├── 001_create_users.sql
│   ├── 002_create_products.sql
│   └── 003_create_orders.sql
├── pkg/                         # Переиспользуемые пакеты
│   └── logger/
│       └── logger.go
├── go.mod
├── go.sum
└── README.md
```

## Установка и запуск

### Вариант 1: Docker Compose (рекомендуется)

Самый простой способ запустить проект с базой данных:

1. **Запустите PostgreSQL и приложение:**
```bash
docker-compose up -d
```

2. **Проверьте статус:**
```bash
docker-compose ps
```

3. **Просмотр логов:**
```bash
docker-compose logs -f app
```

4. **Остановка:**
```bash
docker-compose down
```

**Только база данных (для локальной разработки):**
```bash
docker-compose up -d postgres
```

Миграции применяются автоматически при первом запуске PostgreSQL.

### Вариант 2: Локальная установка

#### Требования

- Go 1.25+
- PostgreSQL 12+ (или используйте Docker Compose только для БД)

#### Шаги установки

1. **Клонируйте репозиторий и установите зависимости:**
```bash
go mod download
```

2. **Запустите PostgreSQL через Docker (если не установлен локально):**
```bash
docker-compose up -d postgres
```

3. **Настройте переменные окружения:**
```bash
# Windows (PowerShell)
$env:DB_HOST="localhost"
$env:DB_PORT="5432"
$env:DB_USER="postgres"
$env:DB_PASSWORD="postgres"
$env:DB_NAME="ta"
$env:PORT="8080"

# Linux/Mac
export DB_HOST=localhost
export DB_PORT=5432
export DB_USER=postgres
export DB_PASSWORD=postgres
export DB_NAME=ta
export PORT=8080
```

4. **Если PostgreSQL установлен локально, создайте базу данных:**
```sql
CREATE DATABASE ta;
```

5. **Примените миграции (если не используете Docker):**
```bash
# Используя psql
psql -U postgres -d ta -f migrations/001_create_users.sql
psql -U postgres -d ta -f migrations/002_create_products.sql
psql -U postgres -d ta -f migrations/003_create_orders.sql
```

6. **Запустите сервер:**
```bash
go run cmd/server/main.go
```

Сервер запустится на `http://localhost:8080`

## API Документация

### Users

#### Регистрация пользователя
```http
POST /api/v1/users
Content-Type: application/json

{
  "firstname": "John",
  "lastname": "Doe",
  "age": 25,
  "is_married": false,
  "password": "password123"
}
```

**Валидация:**
- `age` ≥ 18
- `password` ≥ 8 символов
- `firstname`, `lastname` обязательны

**Ответ:**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "firstname": "John",
  "lastname": "Doe",
  "fullname": "John Doe",
  "age": 25,
  "is_married": false
}
```

#### Получить пользователя
```http
GET /api/v1/users/:id
```

### Products

#### Создать продукт
```http
POST /api/v1/products
Content-Type: application/json

{
  "description": "Laptop",
  "tags": ["electronics", "computers"],
  "quantity": 10
}
```

#### Получить продукт
```http
GET /api/v1/products/:id
```

### Orders

#### Создать заказ
```http
POST /api/v1/orders
Content-Type: application/json

{
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "items": [
    {
      "product_id": "660e8400-e29b-41d4-a716-446655440000",
      "quantity": 2
    }
  ]
}
```

**Бизнес-логика:**
- Проверка наличия товара на складе
- Автоматическое уменьшение количества товара
- Сохранение исторического снимка заказа

#### Получить заказ
```http
GET /api/v1/orders/:id
```

#### Получить заказы пользователя
```http
GET /api/v1/users/:user_id/orders
```

## Тестирование

### Запуск тестов

```bash
# Все тесты
go test ./...

# Конкретный пакет
go test ./internal/service/...

# С покрытием
go test -cover ./internal/service/...
```

### Покрытие тестами

Протестированы критичные методы:

1. **`UserService.Register`**
   - Успешная регистрация
   - Валидация возраста (< 18)
   - Валидация пароля (< 8 символов)

2. **`OrderService.CreateOrder`**
   - Успешное создание заказа
   - Проверка недостаточного количества товара
   - Проверка отсутствия товара

3. **`ProductService.CheckAvailability`**
   - Проверка наличия товара
   - Проверка недостаточного количества

### Архитектура тестов

Используются **моки** для изоляции слоев:
- `MockUserRepository`, `MockProductRepository`, `MockOrderRepository`
- Интерфейсы репозиториев (`UserRepositoryInterface`) позволяют легко подменять реализации

## Безопасность

- **Пароли**: хешируются с помощью bcrypt перед сохранением
- **Валидация**: на уровне Handler (Gin binding) и Service (бизнес-правила)
- **Транзакции**: атомарность операций заказа (проверка + резервирование)

## Историчность данных

Заказы сохраняются в историю через таблицу `order_history`:
- **JSONB snapshot**: полный снимок заказа на момент создания
- **Цена на момент заказа**: `price_at_time` в `order_items`
- Возможность восстановления состояния заказа в любой момент времени

## Middleware

### Logger
Логирует все HTTP запросы с контекстом:
- Метод, путь, статус
- Время выполнения
- IP адрес клиента

### Recovery
Перехватывает паники и возвращает корректный HTTP ответ вместо краша приложения.

### Tracer
Генерирует уникальный `trace_id` для каждого запроса:
- Добавляется в заголовок `X-Trace-ID`
- Доступен в контексте для логирования

## Особенности реализации

### Маппинг между слоями

Каждый слой имеет свои структуры данных:
- **DTO** (Handler) ↔ **Domain** (Service) ↔ **DB Model** (Repository)

Маппинг выполняется через функции в `internal/mapper/` для:
- Изоляции слоев
- Гибкости изменения структур
- Явного преобразования данных

### Интерфейсы репозиториев

Интерфейсы (`UserRepositoryInterface`, `ProductRepositoryInterface`, `OrderRepositoryInterface`) позволяют:
- Легко мокировать для тестов
- Заменять реализацию (например, на in-memory для тестов)
- Следовать принципу Dependency Inversion

## Docker

### Запуск через Docker Compose

Проект включает `docker-compose.yml` для быстрого запуска:

**Запуск всех сервисов (БД + приложение):**
```bash
docker-compose up -d
```

**Только база данных:**
```bash
docker-compose up -d postgres
```

**Остановка:**
```bash
docker-compose down
```

**Остановка с удалением данных:**
```bash
docker-compose down -v
```

### Сборка Docker образа приложения

```bash
docker build -t ta-server .
docker run -p 8080:8080 --env-file .env ta-server
```

### Переменные окружения для Docker

При запуске через `docker-compose up` переменные окружения настраиваются автоматически. Для кастомной конфигурации создайте `.env` файл:

```env
DB_HOST=postgres
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=ta
DB_SSLMODE=disable
PORT=8080
```

**Примечание:** Миграции применяются автоматически при первом запуске PostgreSQL контейнера из папки `migrations/`.

## Лицензия

MIT
